import { query } from "../db/postgres.js";

// Create a new certificate (Health Record with type 'Certificate')
export const createCertificate = async (req, res) => {
    try {
        const { patientName, description, date } = req.body;
        // For certificates generated by students/users, we might use their ID if logged in, 
        // or a generic flow. Assuming authenticated student for now.
        const studentId = req.user.id;

        // Insert into health_records
        const sql = `
            INSERT INTO health_records 
            (student_id, diagnosis, treatment, date, record_type, status, is_manual_upload)
            VALUES ($1, $2, $3, $4, 'Certificate', 'Pending', false)
            RETURNING id;
        `;

        // We treat 'diagnosis' as the certificate title/type and 'treatment' as description/content for simplicity
        // or add specific columns if needed. Using diagnosis/treatment maps well to Certificate Type/Details.
        const result = await query(sql, [studentId, "Medical Certificate", description, date]);

        res.status(201).json({
            message: "Certificate generated successfully",
            certificateId: result.rows[0].id
        });

    } catch (error) {
        console.error("Error creating certificate:", error);
        res.status(500).json({ message: "Error generating certificate", error: error.message });
    }
};

// Verify a certificate (Public or Auth)
export const verifyCertificate = async (req, res) => {
    try {
        const { id } = req.params;
        // Basic check, ensure ID is integer if serial, or UUID. Assuming Serial based on previous file views? 
        // Actually healthRecordController used "SELECT * FROM health_records WHERE id = $1" with params.id.
        // If IDs are integers, we should be careful. 
        // Let's assume it handles string/int conversion or is UUID. 
        // Previous controller used parseInt for doctorId but not for record ID (req.params.id) in getHealthRecordById.
        // Let's safe-guard.

        const sql = `
            SELECT hr.*, u.name as student_name 
            FROM health_records hr
            LEFT JOIN users u ON hr.student_id = u.id
            WHERE hr.id = $1
        `;

        const result = await query(sql, [id]);

        if (result.rows.length === 0) {
            return res.status(404).json({ message: "Certificate not found" });
        }

        const record = result.rows[0];
        res.status(200).json({
            id: record.id,
            studentName: record.student_name,
            type: record.record_type,
            status: record.status,
            date: record.date,
            details: record.diagnosis // or treatment
        });

    } catch (error) {
        console.error("Error verifying certificate:", error);
        res.status(500).json({ message: "Error verifying certificate", error: error.message });
    }
};

// Get Pending Certificates (For Doctor)
export const getPendingCertificates = async (req, res) => {
    try {
        const sql = `
            SELECT hr.*, u.name as student_name, u.email as student_email
            FROM health_records hr
            LEFT JOIN users u ON hr.student_id = u.id
            WHERE hr.record_type = 'Certificate' AND hr.status = 'Pending'
            ORDER BY hr.created_at DESC
        `;
        const result = await query(sql);
        res.status(200).json(result.rows);
    } catch (error) {
        res.status(500).json({ message: "Error fetching certificates", error: error.message });
    }
};

// Get Pending Prescriptions (For Doctor)
// Treat 'General' records as Prescriptions needing verification
export const getPendingPrescriptions = async (req, res) => {
    try {
        const sql = `
            SELECT hr.*, u.name as student_name, u.email as student_email, u.id as student_user_id
            FROM health_records hr
            LEFT JOIN users u ON hr.student_id = u.id
            WHERE hr.record_type = 'General' AND hr.status = 'Pending'
            ORDER BY hr.created_at DESC
        `;
        const result = await query(sql);
        res.status(200).json(result.rows);
    } catch (error) {
        res.status(500).json({ message: "Error fetching prescriptions", error: error.message });
    }
};

// Approve or Reject Record
export const updateRecordStatus = async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = req.body; // 'Verified' or 'Rejected' or 'Approved'

        if (!['Verified', 'Approved', 'Rejected'].includes(status)) {
            return res.status(400).json({ message: "Invalid status" });
        }

        // Normalize Approved -> Verified if needed, or keep as Approved.
        // DocDash uses "Approved". Database default is "Pending".

        const sql = `
            UPDATE health_records 
            SET status = $1
            WHERE id = $2
            RETURNING *
        `;
        const result = await query(sql, [status, id]);

        if (result.rows.length === 0) {
            return res.status(404).json({ message: "Record not found" });
        }

        res.status(200).json({ message: `Record ${status} successfully`, record: result.rows[0] });

    } catch (error) {
        res.status(500).json({ message: "Error updating status", error: error.message });
    }
};
